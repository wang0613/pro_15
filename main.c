#include <stdio.h>
#include <string.h>
//26:数据的存储
/*
 * c语言类型
 * 1：内置类型  char short int long    long long   float  double
 * 2：自定义类型(构造类型)
 *
 * 类型的意义：
 * 1:使用这个类型开辟内存空间的大小(大小决定了使用范围)
 * 2:如果看待内存空间的视角
 */
int main1() {
    int  a  = 10;
    float b = 10.0;

    printf("%p\n",&a);
    printf("%p\n",&b);

    unsigned int; // 无符号位  0-255  -128---127


    return 0;
}
int main2()
{
    //原反补码：
    //00000000000000000000000000010100 [正数的原反补相同]
    //00000000000000000000000000010100
    //00000000000000000000000000010100
    int a = 20;
    //10000000000000000000000000001010 原码
    //11111111111111111111111111110101 反码
    //11111111111111111111111111110110 补码

    //**对于整数来说计算机存储的其实是补码
    int b = -10;


    //1+(-1)
    //1
    //00000000000000000000000000000001

    //-1
    //10000000000000000000000000000001
    //11111111111111111111111111111110
    //11111111111111111111111111111111

    //00000000000000000000000000000001
    //11111111111111111111111111111111   +=
    //10000000000000000000000000000000

    //数据在内存中存储字节的顺序：
    //大端存储模式：是指数据的低位存储到内存的高地址中，而数据的高位，存储到内存的低地址中
    //小端存储模式：是指数据的低位存储到内存的低地址中，而数据的高位，存储到内存的高地址中

//    大端模式优点：符号位在所表示的数据的内存的第一个字节中，便于快速判断数据的正负和大小
//    小端模式优点：1. 内存的低地址处存放低字节，所以在强制转换数据时不需要调整字节的内容


}
//int a = 20;
// 0x00000014
// 数据的低位14  高位0x000000
//低地址--------------------->高地址
//小段14000000    大端00000014

//设计一个小程序，判断当前机器的字节序
//通过将多字节数据强制类型转换成单字节数据，再通过判断起始存储位置是数据高字节还是低字节进行检测
int main3()
{
    int a = 1; //4个字节
    char *  p =(char*)&a;
    //指针解引用时，只访问1一个字节
    if(*(p)==1){
        printf("小端");
    }else
    {
        printf("大端");
    }
}
int main4()
{
    char a = -1; //存储的补码
    //100000000000000000000000000000000001  原码
    //111111111111111111111111111111111110  反码
    //111111111111111111111111111111111111  补码

    //11111111 a中存储的是8个bite位
    signed char b = -1;  //有符号数 相当于 char b = -1;
    unsigned char c = -1;  //无符号数
    //char 会发生整形提升 无符号数 高位补0
    //000000000000000000000000000011111111
    printf("a = %d\n",a);
    printf("b = %d\n",b);
    printf("c = %d\n",c);
}
int main5()
{
    char a = -128;
    //10000000000000000000000010000000 原码
    //11111111111111111111111101111111
    //11111111111111111111111110000000  补码

    //a中只有1个字节 8个bite位  1000000  整形提升 补1
    //11111111111111111111111110000000 无符号数的原码和补码相同

    //%u表示按unsigned int格式输入或输出数据
    printf("%u\n",a);//最大数

    //有符号的char的范围是 -128 -- 127
//    无符号的char的范围是0-255

    char b = 128; //127+1 -->-128
    printf("%u\n",b); //最大数
}
int main6()
{
    int i = -20;
    //10000000000000000010100  原码
    //11111111111111111101011  反码
    //11111111111111111101100  补码
    unsigned int j = 10;
    //00000000000000000001010  正数


    //11111111111111111101100  补码
    //00000000000000000001010  正数
    //相加
    //11111111111111111110110  //补码
    //11111111111111111110101  //-1 反码
    //10000000000000000001010   //原码  -10

    //按照补码的形式进行计算，最后转换为有符号整数
    printf("%d\n",i+j);// -10
}
int main7()
{
    unsigned int i = 0;
    //无符号数 不可能为负数  无符号数>=0
    for(i =9;i>=0;i--)
    {
        printf("%u\n",i); //死循环
    }
}
int main8()
{
    char a[1000];
    int i;
    for(i=0;i<1000;i++)
    {
        //char -128--127
        //任何数 放入 char中都会转成  -128--127 的数    -128-1 =127
        a[i] =-1-i;
    }
    printf("%d",strlen(a));//-1 -2......-127 127 126...0
}
unsigned char i = 0;  //0-255
int main9()
{
    //恒成立 unsigned char 0-255
    for(i = 0;i<= 255;i++)
    {
        printf("hello world\n");
    }
    return 0;
}
int main10()
{
    int n = 9;
    //9.0
    //1001.0
    //(-1)^0*1.001*2^3 二进制2^3
    //(-1)^S * M * 2^E  浮点数在计算机中存储的形式 其中 1<=M<2
    //S= 0
    //M= 1.001
    //E= 3

    //IEEE 754规定：对于32位浮点数，最高位1是符号位s，接着8位是指数E，剩下23位是有效数字M
    //对于64位的浮点数，最高的1位是S，接着的11位是指数E，剩下的52位是有效数字M

    //0 00000000 000000000001001
    //按照浮点数 进行还原 E 为全0
    //(-1)^0 * 0.000000000001001 * 2^-126
    float * pF = (float *)&n;
    printf("%d\n",n); //9
    printf("%f\n",*pF);//0.0000000

    *pF = 9.0;  //按照浮点数进行存
    //1001.0
    //(-1)^0 * 1.001 * 2^3
    //E=3+127=130   10000010
    //0 10000010 00100000000000000000000
    printf("%d\n",n); //1091567616
    printf("%f\n",*pF); //9.000000

    //0.5
    //0.1   即表示为2^-1次方
    //(-1)^0 * 1.0 * 2^-1

    //E=-1
    //E+127 =126 虽然E是-1 但是真正存储到内存中的是126

}
int main66()
{
    float f = 5.5;
    //5.5
    //101.1
    //(-1)^0 * 1.011 * 2^2
    //S = 0
    //M = 1.011
    //E = 2

    //E=2+127=129    --010000001
    //S-0 E-10000001 M-01100000000000000000000

    //0100 0000 1011 0000 0000 0000 0000 0000  四 个二级制位是一个16进制位
    //0x40b00000

    //当E位全0此时浮点数的指数E等于1-127 或者1-1023即为真实值 有效数字M不在加上第一位的1，而是还原为0.xx
    //这样做是为了表示±0，以及接近于0的很小的数字



    return 0;

}

